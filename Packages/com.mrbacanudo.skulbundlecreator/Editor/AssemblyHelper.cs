using System.Collections;
using System.Collections.Generic;

// Crap generated by ChatGPT.
// Asked for an implementation of the KMP algorithm with some changes.

public class AssemblyNameEditor
{
    // KMP algorithm for pattern search
    public static byte[] ReplaceAllOccurrences(byte[] A, byte[] B, byte[] C)
    {
        int M = B.Length;
        int N = A.Length;

        // Create lps[] that will hold the longest prefix suffix values for pattern
        int[] lps = new int[M];
        ComputeLPSArray(B, M, lps);

        int i = 0; // index for A[]
        int j = 0; // index for B[]

        List<int> matchIndices = new List<int>(); // indices where pattern B starts in A
        while (i < N)
        {
            if (B[j] == A[i])
            {
                j++;
                i++;
            }
            if (j == M)
            {
                matchIndices.Add(i - j); // add the start index of the matched pattern B
                j = 0; // reset j to 0 instead of lps[j - 1]
            }

            // mismatch after j matches
            else if (i < N && B[j] != A[i])
            {
                if (j != 0)
                    j = lps[j - 1];
                else
                    i = i + 1;
            }
        }

        // Construct the result using the match indices
        List<byte> result = new List<byte>();
        int nextMatchIndex = 0; // index in matchIndices to track the next replacement
        for (i = 0; i < N;)
        {
            // If we have more matches and we've reached the next match start index
            if (nextMatchIndex < matchIndices.Count && i == matchIndices[nextMatchIndex])
            {
                // Add C to the result and move the pointer by the length of B
                result.AddRange(C);
                i += B.Length;
                nextMatchIndex++;
            }
            else
            {
                // Just add the current character to the result and move the pointer by 1
                result.Add(A[i]);
                i++;
            }
        }

        return result.ToArray();
    }

    static void ComputeLPSArray(byte[] B, int M, int[] lps)
    {
        // length of the previous longest prefix suffix
        int len = 0;
        int i = 1;
        lps[0] = 0; // lps[0] is always 0

        // the loop calculates lps[i] for i = 1 to M-1
        while (i < M)
        {
            if (B[i] == B[len])
            {
                len++;
                lps[i] = len;
                i++;
            }
            else // (pat[i] != pat[len])
            {
                if (len != 0)
                {
                    len = lps[len - 1];
                }
                else // if (len == 0)
                {
                    lps[i] = len;
                    i++;
                }
            }
        }
    }
}
